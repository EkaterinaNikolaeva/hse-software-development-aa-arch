# Документация к тестированию

## Юнит-тестирование

 Для написания юнит-тестов используется библиотека GTest.

 Юнит-тесты расположены в `rsq_library/tests`. Запуск тестов осуществляется в `rsq_library/tests/main.cpp`, а классы, содержащие сами тесты, в `rsq_library/tests/include`

Все тесты - шаблонные, позволяющие протестировать любой класс, наследующийся от IRSQ.

### irsq_test.hpp

Проверяются базовые случаи: небольшой размер массива, преднаписанные запросы. Результат сравнивается с предподсчитанной константой. Проверяется выброс исключений в случае некорректного запроса.

### irsq_random_test.hpp

Класс `RandomIRSQTest` принимает размер массива (`vector_size`), на которым будет строиться структура, число действий, которые будут совершаться(`total_actions_number`), вероятность совершения запроса изменения элемента (`update_probability`), минимальный (`min_element`) и максимальный (`min_element`) размер числа в массиве.

Сам массив генерируется рандомно. Также случайно генерируются тип текущего запроса и сам запрос.

Полученные результаты сравниваются с результатами, полученными наивным решением задачи RSQ.

Данный тест позволяет выявить неожиданные ошибки, а также покрыть большое число входных значений и сымитировать реальные условия работы.

### irsq_better_test.hpp

Тест проверяет корректную работу на больших числах:

* `TestBigVectorSize` - работу на больших размерах вектора

* `TestBigPositiveNumbers` - работу с большими положительными элементами массива. Проверяется отсутсвтие переполнений

* `TestBigNegativeNumbers` - работу с большими отрицательными элементами массива

## Вспомогательные утилиты

### utils/random_data_generator.hpp

Класс, удобный для генерации случайных запросов. Позволяет получить случайное число, ограниченное минимальным и максимальным значением, сгенерировать случайный массив, а также порядок хода, подчиняющийся распределению Бернулли.

### utils/consistency_checker.hpp

Класс, позволяющий удобно сравнивать значения запроса суммы, полученные очередной реализацией RSQ с результатом наивного решения.
