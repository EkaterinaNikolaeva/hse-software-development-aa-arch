# Алгоритмы, решающие задачу RSQ

## Наивное решение

#### Запрос суммы
Простое суммирование элементов на заданном диапазоне

#### Запрос присваивания
Простое присваивание нового значения элементу массиву 

#### Сложность решения:

* Пространственная: $\mathcal{O}(n)$

* Временная:

    * Запрос суммы: $\mathcal{O}(r - l + 1)$
    * Запрос присваивания: $\mathcal{O}(1)$


## Дерево отрезков

Дерево отрезков - структура данных. Оно строится на массиве: каждой вершине ДО соответсвует некоторый отрезок (или полуинтервал) массива. Корню дерева соотвествует $[0; n)$, а каждая вершина (не считая листьев) имеет ровно двух сыновей.

Высота дерева отрезков $\Theta(\log n)$, так как на каждом уровне длина отрезка уменьшается вдвое. В это же время любой полуинтвервал разбивается на $\mathcal{O}(\log n)$ полуинтервалов, за которые отвечают вершины ДО.

### Реализация сверху

Реализуется на полуинтервалах.

#### Построение

Достаточно выделить массив размером $4n$, где $n$ - размер массива, по которому строим ДО.

1. Строим ДО рекурсивно
2. В листе ДО ($l + 1 == r$) храним $l$-й элемент массива
3. В остальных вершинах храним сумму значений в детях

#### Запрос суммы

1. Если находимся в вершине, которой соотвествует полуинтвервал, не пересекающийся с полуинтервалом из запроса, то возвращаем 0

2. Если находимся в вершине, которой соотвествует полуинтвервал, полностью лежащий в полуинтервале из запроса, то возвращам значение в вершине

3. Иначе запускаемся рекурсивно от детей, возвращаем сумму

Временная сложность - количество полуинтервалов, на которые разобьется желаемый полуинтервал

#### Запрос присваивания

1. Если находимся в листе, то меняем значение в вершине

2. Иначе смотрим, в каком из детей вершины лежит изменяемый индекс, запускаемся рекурсивно от этого ребенка

3. Обновляем значение, лежащее в вершине, суммой значений в детях

Временная сложность - глубина дерева

#### Сложность решения

* Пространственная: $\mathcal{O}(n)$

* Временная:

    * Построение: $\mathcal{O}(n)$
    * Запрос суммы: $\mathcal{O}(\log n)$
    * Запрос присваивания: $\mathcal{O}(\log n)$

### Реализация снизу

Реализуется на отрезках.

#### Построение

Достаточно выделить массив размеров $2n$, где $n$ - размер массива, по которому строим ДО.

1. Заполняем значения $t[i + n]$ (листья) соответствующими значения массива

2. Каждому из значений $t[i]$ для $i = (n-1)...0$ присваиваем $t[2 * i] + t[2 * i + 1]$

#### Запрос суммы

1. Сперва спустимся к листьям: $l += n;\, r += n$

2. Вершины кроме, возможно, крайних, разбиваются на пары (общий отец)

3. Отрежем вершины без пары – нечётный $l$ и чётный $r$, перейдём к отрезку отцов $[l/2,
r/2]$

#### Запрос присваивания

1. Обновляем значение в листе

2. Пересчитали значения во всех ячейках на пути до корня (все отрезки, содержащие индекс, в котором меняем значение)

#### Сложность решения

* Пространственная: $\mathcal{O}(n)$

* Временная:

    * Построение: $\mathcal{O}(n)$
    * Запрос суммы: $\mathcal{O}(\log(r - l + 1))$
    * Запрос присваивания: $\mathcal{O}(\log n)$

## Дерево Фенвика

## Корневая декомпозиция

## Решения, использующие деревья поиска по неявному ключу

### Декартово дерево

### AVL-дерево

## B-дерево

