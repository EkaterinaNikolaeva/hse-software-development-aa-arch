# Алгоритмы, решающие задачу RSQ

## Наивное решение

#### Запрос суммы
Простое суммирование элементов на заданном диапазоне

#### Запрос присваивания
Простое присваивание нового значения элементу массиву 

#### Сложность решения:

* Пространственная: $\mathcal{O}(n)$

* Временная:

    * Запрос суммы: $\mathcal{O}(r - l + 1)$
    * Запрос присваивания: $\mathcal{O}(1)$


## Дерево отрезков

Дерево отрезков - структура данных. Оно строится на массиве: каждой вершине ДО соответсвует некоторый отрезок (или полуинтервал) массива. Корню дерева соотвествует $[0; n)$, а каждая вершина (не считая листьев) имеет ровно двух сыновей.

Высота дерева отрезков $\Theta(\log n)$, так как на каждом уровне длина отрезка уменьшается вдвое. В это же время любой полуинтвервал разбивается на $\mathcal{O}(\log n)$ полуинтервалов, за которые отвечают вершины ДО.

### Реализация сверху

Реализуется на полуинтервалах.

#### Построение

Достаточно выделить массив размером $4n$, где $n$ - размер массива, по которому строим ДО.

1. Строим ДО рекурсивно
2. В листе ДО ($l + 1 == r$) храним $l$-й элемент массива
3. В остальных вершинах храним сумму значений в детях

#### Запрос суммы

1. Если находимся в вершине, которой соотвествует полуинтвервал, не пересекающийся с полуинтервалом из запроса, то возвращаем 0

2. Если находимся в вершине, которой соотвествует полуинтвервал, полностью лежащий в полуинтервале из запроса, то возвращам значение в вершине

3. Иначе запускаемся рекурсивно от детей, возвращаем сумму

Временная сложность - количество полуинтервалов, на которые разобьется желаемый полуинтервал

#### Запрос присваивания

1. Если находимся в листе, то меняем значение в вершине

2. Иначе смотрим, в каком из детей вершины лежит изменяемый индекс, запускаемся рекурсивно от этого ребенка

3. Обновляем значение, лежащее в вершине, суммой значений в детях

Временная сложность - глубина дерева

#### Сложность решения

* Пространственная: $\mathcal{O}(n)$

* Временная:

    * Построение: $\mathcal{O}(n)$
    * Запрос суммы: $\mathcal{O}(\log n)$
    * Запрос присваивания: $\mathcal{O}(\log n)$

### Реализация снизу

Реализуется на отрезках.

#### Построение

Достаточно выделить массив размеров $2n$, где $n$ - размер массива, по которому строим ДО.

1. Заполняем значения $t[i + n]$ (листья) соответствующими значения массива

2. Каждому из значений $t[i]$ для $i = (n-1)...0$ присваиваем $t[2 * i] + t[2 * i + 1]$

#### Запрос суммы

1. Сперва спустимся к листьям: $l += n;\, r += n$

2. Вершины кроме, возможно, крайних, разбиваются на пары (общий отец)

3. Отрежем вершины без пары – нечётный $l$ и чётный $r$, перейдём к отрезку отцов $[l/2,
r/2]$

#### Запрос присваивания

1. Обновляем значение в листе

2. Пересчитали значения во всех ячейках на пути до корня (все отрезки, содержащие индекс, в котором меняем значение)

#### Сложность решения

* Пространственная: $\mathcal{O}(n)$

* Временная:

    * Построение: $\mathcal{O}(n)$
    * Запрос суммы: $\mathcal{O}(\log(r - l + 1))$
    * Запрос присваивания: $\mathcal{O}(\log n)$

## Дерево Фенвика

Для построения дерева Фенвика требуется массив $ t $, размер которого равен $ n $, где $ n $ — размер исходного массива $ a $. Элементы массива $ t $ определяются как:

$t[i] = \sum_{k=F(i)}^i a[k]$

где функция $ F(i) $ выбирается так, чтобы для каждого индекса $ i $ выполнялось неравенство $ F(i) \leq i $. 

### Построение

Для построения можно заполнить массив $t$ нулями и $n$ раз вызвать присваивние или префиксными суммами посчитать массив $t$

### Запрос суммы

Запрос суммы на отрезке $ [l; r] $ может быть выполнен с помощью следующей формулы:

$\text{sum}(l, r) = \text{sum}(r) - \text{sum}(l-1)$

где функция суммирования для префикса определяется как:

$\text{sum}(k) = t[k] + \text{sum}(F(k)-1)$

Таким образом, для получения суммы на заданном диапазоне необходимо выполнить несколько операций сложения по элементам массива $ t $

### Запрос присваивания

Для обновления значения элемента массива $ a[k] $ на величину $ delta $, необходимо обновить все элементы массива $ t $, которые зависят от измененного элемента, а именно те $ t[i] $, где $ F(i)\leq k \leq i $

При достаточно хорошей F найти все такие i достаточно легко

### Сложность решения

* **Пространственная сложность**: $\mathcal{O}(n)$
* **Временная сложность**:
    * Построение: $\mathcal{O}(n)$
    * Запрос суммы и присваивания: зависят от функции F

### Варианты функции F


  - $ F(i) = i \& (i+1)$
  - $ F(i) = i - (i \& -i) + 1$

  дают $\mathcal{O}(\log n)$ на сумму и присваивние
  
## Корневая декомпозиция

#### Построение

1. Разделим массив на блоки размером по $c \approx \sqrt{n}$ элементов в каждом и посчитаем сумму на каждом блоке. Заметим, что блоков получилось $approx \sqrt{n}$

#### Запрос суммы

1. Запрашиваемый отрезок состоит из не более чем $\sqrt{n}$ полных блоков. Для всех таких блоков прибавим к ответу предподсчитанную сумму элементов в блоке

2. Запрашиваемый отрезок пересекается частично с не более чем двумя блоками. Посчитаем сумму элементов этих блоков, которые попали в запрашиваемый отрезок, прибавим к ответу

#### Запрос присваивания

1. Изменим значение элемента в массиве

2. Пересчитаем сумму элементов в соответсвующем блоке (вычитаем предыдущее значение и прибавляем новое)

#### Сложность решения

* Пространственная: $\mathcal{O}(n)$

* Временная:

    * Построение: $\mathcal{O}(n)$
    * Запрос суммы: $\mathcal{O}(\sqrt{n})$
    * Запрос присваивания: $\mathcal{O}(1)$


## Решения, использующие деревья поиска по неявному ключу

BST – binary search tree (бинарное дерево поиска). В каждой вершине пара $(x, data)$.
Левое поддерево содержит пары $(x, data)$ со строго меньшими $x$. Правое поддерево содержит пары $(x, data)$ со строго большими $x$.

Обычно ключи задают на множестве порядок, и все запросы к BST как-то привязаны к этому порядку. Неявный ключ нужен, чтобы изобрести массив с вставкой в середину, удалением из середины и стандартным обращением в ячейку. **Решение такое**: выкинем ключи, а вместо них будем поддерживать информацию, которая поможет неявно восстановить ключ, когда он нам будет нужен, а именно - размер поддерева вершины. Тогда ключ (позицию элемента) можно восстановить как число элементов, которые находятся слева от него — что можно пересчитывать во время спуска по дереву.

$split(t, x)$ делит $t$ на $l: {a: a < x}$ и $r = {a \geq x}$. Соответсвенно, в неявном ключе - по размеру делит на префикс и суффикс массива.

Если все ключи в $l$ меньше, чем в $r$, то $merge(l, r)$ - BST, полученное объединением ключей $l$ и $r$. В случае неявного ключа - соединение массивов.

### Декартово дерево

Декартово дерево от множества пар $(x_i, y_i)$ – структура, являющаяся BST по $x$ и кучей с минимумом в корне по $y$.

Декартово дерево (treap) от множества ключей $x_i$ – декартово дерево пар $(x_i, random)$

Соответсвенно, в ДД по неявному ключу поддерживаем пары $(size, random)$.

#### split

1. База индукции - если пришли в вершину NULL

2. Иначе, если размер левого сына + 1 (текущая вершина) не больше $k$, то текущая вершина и левый ребенок попадет в левое дерево, рекурсивно делим правого ребенка

3. Иначе рекурсивно делим левого ребенка

#### merge

1. База индукции - если $l$ NULL, возвращаем NULL, если $r$ NULL, то $l$

2. Если приоритет корня $l$ меньше, то корень $l$ - корень смердженного дерева, левый ребенок $l$ - левый ребенок результата, а правый - нужно смерджить правого ребенка $l$ и $r$, то есть рекурсивно запустим $l \rightarrow r = merge(l \rightarrow r, r)$

3. Иначе корень $r$ - корень смердженного дерева, правый ребенок $r$ - правый ребенок результата, а левый - нужно смерджить левого ребенка $r$ и $l$, то есть рекурсивно запустим $r \rightarrow l = merge(l, r \rightarrow l)$

#### Построение

Будем делать последовательный Add элементов массива. $Add = split + merge + merge$. Поддерживаем в вершине дополнительную информация - сумму элементов в поддереве

#### Запрос суммы

1. Делаем split нужного отрезка (2 split префикса), получаем три поддерева (префикс, наш отрезок, суффикс)

2. Берем сумму в корне получившегося дерева

3. Мерджим префикс, наш отрезок и суффикс

#### Запрос присваивания

Нужно удалить старый элемент массива и добавить новый, то есть Del(i) + Add(i, x)

$Del = split + split + merge$

#### Сложность решения

* Пространственная: $\mathcal{O}(n)$

* Временная:

    * Построение: $\mathcal{O}(n \log n)$
    * Запрос суммы: $\mathcal{O}(\log n)$
    * Запрос присваивания: $\mathcal{O}(\log n)$


### AVL-дерево

### B-дерево

