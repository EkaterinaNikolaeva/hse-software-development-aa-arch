# Отчёт по сравнению алгоритмов
## Экспериментальная установка
Экспериментальная установка состоит из двух бенчмарков, которые запускают одинаковые наборы инструкций/тестовых сценариев и считают их время работы. Каждый сценарий поддерживает работу на массивом размера `n`, что позволит построить график времени работы методов от размера массива. Для запуска используется Docker. 

Тестовые сценарии для постройки графиков:
* I: `n` последовательных пар операций Query и Update. Update в каждой ячейке массива. Query по всему массиву
* II: `n` последовательных пар операций Query и Update со случайными входными параметрами
* III: 99% Query и 1% Update в случайном порядке. Всего `2n` операций со случайными входными параметрами
* IV: 1% Query и 99% Update в случайном порядке.  Всего `2n` операций со случайными входными параметрами

### Google Benchmark
Для запуска используется одноимённая библиотека 
### Собственный бенчмарк
Самописный бенчмарк в основе которого подсчёт времени работы функции с использованием `std::chrono`
## Тестируемые алгоритмы 
### Дерево отрезков, реализация сверху
   * Построение: $\mathcal{O}(n)$
   * Запрос суммы: $\mathcal{O}(\log n)$
   * Запрос присваивания: $\mathcal{O}(\log n)$
### Дерево отрезков, реализация снизу
   * Построение: $\mathcal{O}(n)$
   * Запрос суммы: $\mathcal{O}(\log(r - l + 1))$
   * Запрос присваивания: $\mathcal{O}(\log n)$
### Дерево Фенвика
  * Построение: $\mathcal{O}(n)$
  * Запрос суммы: $\mathcal{O}(r - l + 1)$
  * Запрос присваивания: $\mathcal{O}(1)$
### Корневая декомпозиция
   * Построение: $\mathcal{O}(n)$
   * Запрос суммы: $\mathcal{O}(\sqrt{n})$
   * Запрос присваивания: $\mathcal{O}(1)$
  
## Результаты 
### I 
<img src="img/naive.png" style="width:50%; height:auto;">

### II
<img src="img/random.png" style="width:50%; height:auto;">

### III
<img src="img/random_update.png" style="width:50%; height:auto;">

### IV

<img src="img/random_query.png" style="width:50%; height:auto;">
