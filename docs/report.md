# Отчёт по сравнению алгоритмов

## Экспериментальная установка

Экспериментальная установка состоит из двух бенчмарков, которые запускают одинаковые наборы инструкций/тестовых
сценариев и считают их время работы. Каждый сценарий поддерживает работу на массивом размера `n`, что позволит построить
график времени работы методов от размера массива. Для запуска используется Docker.

Тестовые сценарии для постройки графиков:

* I: `n` последовательных пар операций Query и Update. Update в каждой ячейке массива. Query по всему массиву
* II: `n` последовательных пар операций Query и Update со случайными входными параметрами
* III: 99% Query и 1% Update в случайном порядке. Всего `2n` операций со случайными входными параметрами
* IV: 1% Query и 99% Update в случайном порядке. Всего `2n` операций со случайными входными параметрами

### Google Benchmark

Для запуска используется одноимённая библиотека

### Собственный бенчмарк

Самописный бенчмарк в основе которого подсчёт времени работы функции с использованием `std::chrono`

## Тестируемые алгоритмы

### Дерево отрезков, реализация сверху

* Построение: $\mathcal{O}(n)$
* Запрос суммы: $\mathcal{O}(\log n)$
* Запрос присваивания: $\mathcal{O}(\log n)$

### Дерево отрезков, реализация снизу

* Построение: $\mathcal{O}(n)$
* Запрос суммы: $\mathcal{O}(\log(r - l + 1))$
* Запрос присваивания: $\mathcal{O}(\log n)$

### Дерево Фенвика

* Построение: $\mathcal{O}(n)$
* Запрос суммы: $\mathcal{O}(r - l + 1)$
* Запрос присваивания: $\mathcal{O}(1)$

### Корневая декомпозиция

* Построение: $\mathcal{O}(n)$
* Запрос суммы: $\mathcal{O}(\sqrt{n})$
* Запрос присваивания: $\mathcal{O}(1)$

### Декартово дерево

* Построение: $\mathcal{O}(n \log n)$
* Запрос суммы: $\mathcal{O}(\log n)$
* Запрос присваивания: $\mathcal{O}(\log n)$

## Результаты

### I

<img src="img/naive.png" style="width:50%; height:auto;">

Вывод: график показывает, что наивная имплементация прогрывает при числе большом числе операций, однако выигрывает при
числе операций меньшем 30, так как не требует дополнительных ресурсов на построение структуры.

Также решениям значительно уступает корневая оптимизация. Наиболее эффективна реализация дерева отрезков снизу.

### II

<img src="img/random.png" style="width:50%; height:auto;">

Вывод: наиболее оптимальны решения задачи RSQ деревом Фенвика и деревом отрезков снизу.

### III

<img src="img/random_update.png" style="width:50%; height:auto;">

Вывод: наиболее оптимальна при большом количестве запросов Update реализация, использующая корневую оптимизацию.

### IV

<img src="img/random_query.png" style="width:50%; height:auto;">

Вывод: при большом количестве операций получения суммы на отрезке оптимальнее использовать дерево Фенвика или дерево
отрезков снизу.

## Выводы

Наиболее универсальными и оптимальными являются решения, использующие дерево отрезков снизу или дерево Фенвика. Обе
структуры строятся за $\mathcal{O}(n)$ и отвечают на запросы за $\mathcal{O}(\log n)$ с хорошей константой.

Однако если известно, что подавляющее большинство запросов - запросы изменения элементов, то эффективнее использовать
корневую оптимизацию, так как она отвечает на запрос изменения элемента за $\mathcal{O}(1)$, а на более редкие запросы
суммы на отрезке за $\mathcal{O}(\sqrt{n})$.

## Оценка памяти

Для оценки потребления памяти использовался инструмент Massif из набора Valgrind. Massif позволяет отслеживать выделение
и освобождение памяти в процессе выполнения программы, а также строить подробные отчеты о пиках использования памяти.

### Анализ пиков потребления памяти

В ходе выполнения эксперимента были зафиксированы несколько значительных пиков выделения памяти:

#### Первый значительный пик (~474 KB)

- Произошел на **snapshot 53**.
- Основное выделение связано
  с `rsq::benchmark::ExperimentManagerBase::MakeNaiveActions<rsq::SegmentTree>(unsigned long)` (*
  *experiment_manager_base.hpp:15**).
- Вызвано созданием вектора для хранения данных перед запуском эксперимента.
- **Алгоритм**: `SegmentTree`
- **Сценарий**: 1) Naive

#### Максимальный пик (~2 MB)

- Зафиксирован на **snapshot 55**.
- Основной объем памяти (около **2 MB**) используется для
  работы `rsq::SegmentTree::SegmentTree(std::vector<int> const&)` (**segment_tree.hpp:87**), что указывает на выделение
  памяти для структуры данных перед началом измерений.
- **Алгоритм**: `SegmentTree`
- **Сценарий**: 1) Naive

#### Второй значительный пик (~2 MB)

- Произошел на **snapshot 65**.
- Причина аналогична предыдущему случаю — массив `std::vector<int>` при создании `rsq::SegmentTree`.
- **Алгоритм**: `SegmentTree`
- **Сценарий**: 3) Random_Update

#### Заключительный пик (~874 KB)

- Зафиксирован на **snapshot 76**.
- Связан с выделением памяти в `rsq::benchmark::ExperimentManagerBase::MakeNaiveActions<rsq::NaiveRSQ>` (*
  *experiment_manager_base.hpp:15**).
- **Алгоритм**: `NaiveRSQ`
- **Сценарий**: 3) Naive

### Выводы

- **Наибольшее потребление памяти** продемонстрировал **SegmentTree**, что связано с его структурой хранения и
  выделением памяти под векторы.
- **Максимальный пик памяти (2 MB)** наблюдался при инициализации `SegmentTree`, что подтверждает его высокие затраты на
  создание структуры данных.
- **Алгоритм `NaiveRSQ`** потребляет значительно меньше памяти, но при этом менее эффективен с точки зрения времени
  выполнения.
- **Сценарий `Naive`** приводит к пикам памяти из-за необходимости хранения всех данных в массиве.
- **Сценарий `Random_Update`** также показал высокий расход памяти, что объясняется частыми изменениями данных
  в `SegmentTree`.
- Алгоритмы, не представленные в тексте, вероятно, не создают значительных пиков в использовании памяти, так как они
  не требуют больших выделений памяти или используют более эффективные структуры данных.